# Docker Compose Configuration for Secure Redis Implementation
#
# This configuration provides TLS-enabled Redis with comprehensive security features:
# - TLS encryption (rediss://) with certificate-based authentication
# - Password authentication with strong password requirements
# - Network isolation with internal Docker networks
# - Health checks with TLS validation
# - Persistent data storage with secure volumes
#
# Usage:
#   1. Generate certificates: ./scripts/init-redis-tls.sh
#   2. Start services: docker-compose -f docker-compose.secure.yml up -d
#   3. Test connection: redis-cli --tls --cert certs/redis.crt --key certs/redis.key --cacert certs/ca.crt -p 6380 ping
#
# Environment Variables Required:
#   REDIS_PASSWORD: Strong password for Redis authentication (auto-generated by setup script)

version: '3.8'

services:
  redis:
    image: redis:7-alpine
    container_name: redis_secure
    restart: unless-stopped

    # Network configuration - isolated internal network
    networks:
      - redis_internal

    # Volume mounts for TLS certificates and data persistence
    volumes:
      - ./certs:/tls:ro                    # TLS certificates (read-only)
      - redis_data:/data                   # Persistent Redis data

    # Secure Redis configuration with TLS-only mode
    command: >
      redis-server
      --tls-port 6380
      --port 0
      --tls-cert-file /tls/redis.crt
      --tls-key-file /tls/redis.key
      --tls-ca-cert-file /tls/ca.crt
      --tls-protocols "TLSv1.2 TLSv1.3"
      --requirepass ${REDIS_PASSWORD:-secure_default_password}
      --protected-mode yes
      --save 900 1
      --save 300 10
      --save 60 10000
      --appendonly yes
      --appendfsync everysec
      --maxmemory-policy allkeys-lru
      --tcp-keepalive 300
      --timeout 300
      --loglevel notice

    # Environment configuration
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD:-secure_default_password}
      - TZ=UTC

    # TLS health check with certificate validation
    healthcheck:
      test: |
        redis-cli --tls \
          --cert /tls/redis.crt \
          --key /tls/redis.key \
          --cacert /tls/ca.crt \
          -p 6380 \
          --raw incr ping_counter
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

    # Resource limits for production deployment
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'

    # Security settings
    security_opt:
      - no-new-privileges:true

    # User configuration (non-root)
    user: "redis:redis"

  # Backend service with secure Redis connection
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: backend_secure
    restart: unless-stopped

    # Network configuration - access to both internal Redis and external clients
    networks:
      - redis_internal      # Access to secure Redis
      - app_external        # External API access

    # Environment variables for secure Redis connection
    environment:
      # Redis connection configuration
      - REDIS_URL=rediss://redis:6380
      - REDIS_PASSWORD=${REDIS_PASSWORD:-secure_default_password}
      - REDIS_TLS_ENABLED=true
      - REDIS_TLS_CERT_PATH=/tls/redis.crt
      - REDIS_TLS_KEY_PATH=/tls/redis.key
      - REDIS_TLS_CA_PATH=/tls/ca.crt
      - REDIS_VERIFY_CERTIFICATES=true

      # Application security configuration
      - NODE_ENV=${NODE_ENV:-development}
      - API_KEY=${API_KEY:-development-key}
      - CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS:-http://localhost:3000,http://localhost:8501}

      # Cache configuration
      - CACHE_PRESET=ai-development
      - ENABLE_AI_CACHE=true
      - REDIS_ENCRYPTION_KEY=${REDIS_ENCRYPTION_KEY}

      # Resilience configuration
      - RESILIENCE_PRESET=development

      # Logging
      - LOG_LEVEL=${LOG_LEVEL:-INFO}

    # Mount TLS certificates
    volumes:
      - ./certs:/tls:ro     # TLS certificates (read-only)

    # Port mapping for API access
    ports:
      - "8000:8000"         # FastAPI application

    # Service dependencies
    depends_on:
      redis:
        condition: service_healthy

    # Health check for backend service
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

    # Resource limits
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '1.0'
        reservations:
          memory: 512M
          cpus: '0.5'

  # Frontend service (optional - for complete development environment)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: frontend_secure
    restart: unless-stopped

    # External network only
    networks:
      - app_external

    # Environment configuration
    environment:
      - BACKEND_URL=http://backend:8000
      - NODE_ENV=${NODE_ENV:-development}

    # Port mapping
    ports:
      - "8501:8501"         # Streamlit application

    # Service dependencies
    depends_on:
      backend:
        condition: service_healthy

    # Health check
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8501/_stcore/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

# Network configuration for security isolation
networks:
  # Internal network for Redis access - isolated from external traffic
  redis_internal:
    driver: bridge
    internal: true          # No external internet access
    driver_opts:
      com.docker.network.bridge.name: redis_internal
    ipam:
      config:
        - subnet: 172.20.0.0/16

  # External network for API access
  app_external:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.name: app_external
    ipam:
      config:
        - subnet: 172.21.0.0/16

# Volume configuration for data persistence
volumes:
  redis_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ./data/redis

# Additional security and monitoring services (optional)
#
# Uncomment the following services for enhanced security monitoring:
#
#  redis-monitor:
#    image: redislabs/redisinsight:latest
#    container_name: redis_monitor_secure
#    networks:
#      - redis_internal
#    environment:
#      - REDIS_URL=rediss://redis:6380
#      - REDIS_PASSWORD=${REDIS_PASSWORD}
#      - REDIS_TLS_CERT=/tls/redis.crt
#      - REDIS_TLS_KEY=/tls/redis.key
#      - REDIS_TLS_CA=/tls/ca.crt
#    volumes:
#      - ./certs:/tls:ro
#    ports:
#      - "8001:8001"
#    depends_on:
#      redis:
#        condition: service_healthy

# Security Notes:
# 1. Redis runs in TLS-only mode (port 6379 disabled, only 6380 with TLS)
# 2. Network isolation prevents direct Redis access from external networks
# 3. All passwords should be generated securely (use ./scripts/setup-secure-redis.sh)
# 4. Certificates are mounted read-only to prevent tampering
# 5. Health checks validate TLS connections
# 6. Resource limits prevent resource exhaustion attacks
# 7. Non-root user execution reduces privilege escalation risks

# Production Deployment Notes:
# - Use Docker secrets for password management
# - Mount certificates from secure external sources
# - Enable Docker Content Trust for image verification
# - Use specific image tags instead of 'latest'
# - Configure log rotation and monitoring
# - Set up backup strategies for redis_data volume